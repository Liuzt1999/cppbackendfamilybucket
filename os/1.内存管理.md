# 虚拟内存 
os提供一种机制将不同进程的虚拟地址和不同的内存地址映射起来。  
可以使进程的运行内存超过物理内存的大小，每个进程的虚拟内存空间是私有的，可以解决多进程之间的地址冲突问题。  
## 内存分段  
分段机制下的虚拟内存地址由段选择因子（主要是段号）和段内偏移量表示。通过段号查询段表得到段的基址，再通过段内偏移量获得物理内存中的地址。  
分段管理中，不同的进程被分成不同的连续的段存储在物理内存中，这会导致：  
1. 内存碎片问题：
   主要是外部碎片，两个进程间的连续的空间不足以支持新的进程。  
2. 内存交换效率问题：
    为了解决外部碎片，使用外存当作内存的缓冲区，将物理内存中占用的内存swap到外存，再紧贴着上一块空间装载回内存。但如果交换的是一个占内存空间很大的进程，效率很低。
## 内存分页  
将内存按照固定的大小分成一个个的页（Linux下每个页的大小是4K）。通过页表来实现虚拟内存和物理内存的映射。这种方式下每个页之间都是紧凑的，不会产生外部碎片，但是页是分配的最小单元，如果一个页没有被占满，这个页也不会分配给其它的进程，因此会产生内部碎片。  
分页管理下，内存交换的单位是页，需要交换的内存空间很小，效率高。  
分页管理下的虚拟内存地址由页号和页内偏移量表示，通过页号查询页表获得页的基址，再通过页内偏移量获得物理地址。  
这种简单分页的问题：  
页表一定要能够覆盖全部的虚拟地址空间，对于32位的机器，虚拟地址空间的大小为2^32，页的大小是2^12，会产生2^20个页表项，每个页表项的大小是4字节，每个页表需要占用的空间是4MB，每个进程都有自己的虚拟地址空间，需要很大的内存来存放页表。  
为了解决这个问题，使用多级页表，如二级页表将2^20的页表分成2^10个一级页表项，每个一级页表项指向一个有2^10个页表项的二级页表。一级页表在开始就创建，而二级页表在使用的时候才会创建，通过这种方式来节省内存空间。对于64位的系统，会使用四级页表。  
多级页表的虚拟内存地址到物理内存地址的映射多了几个步骤，为了提高效率，在CPU中加入了一个专门存放最常访问的页表项的cache（TLB，页表缓存，快表）。  
## 段页式内存管理  
将程序划分成多个有逻辑意义的段（分段），再把每个段划分为多个页（分页）。这时的虚拟内存地址由段号、段内页号、页内偏移量组成。查询物理内存地址需要：
1.  访问段表得到页表起始地址
2.  访问页表得到物理页号
3.  将物理页号和页内偏移量组合得到物理地址
# Linux进程的内存分布
Linux的虚拟地址空间被分为内核空间和用户空间，32位系统的内核空间占用1G，位于高地址，3G是用户空间，位于低地址。64位的高地址的128T是内核空间，低地址的128T是用户空间。每个进程的虚拟内存的内核空间是共享的。  
用户空间由低地址到高地址为：  
1.  代码段：可执行的二进制代码
2.  数据段：已经初始化的全局变量和静态变量
3.  bss段：未初始化的全局变量和静态变量
4.  堆段：动态分配的内存，向上增长（低位to高位）
5.  文件映射段：包括动态库、共享内存等，向下增长
6.  栈段：局部变量和函数调用的上下文。栈的大小固定，向下增长
# malloc如何分配内存  
malloc源码里定义了一个阈值（128K）：  
1.  分配的内存小于128K，则通过brk（）系统调用在堆申请内存
2.  分配的内存大于128K，则通过系统调用mmap（）系统调用在文件映射段申请内存
## malloc（1）会分配多大内存：  
分配的内存小于128K，会通过brk（）系统调用在堆里分配内存，但是会预分配更大的空间来作为内存池  
## free释放内存会归还给os吗？
通过brk申请的内存不会归还，而是缓存在malloc的内存池，待下次分配  
通过mmap申请的内存会归还  
## 为什么不全部使用brk/mmap分配内存？  
brk的内存不会归还，频繁的brk申请大于内存池中可复用的内存会导致内存泄漏  
mmap释放后会归还，因此每次申请都会发生运行态的切换和缺页中断，开销大  
## free怎么知道要释放多大内存？
malloc返回的内存起始地址比堆空间的起始地址多了16字节，用来保存该内存块的描述信息，其中包括该内存块的大小。 
# 内存紧张时的内存回收
程序通过malloc申请内存时，实际上申请的虚拟内存，此时不会分配物理内存。当程序读写了这块虚拟内存，CPU去访问这个虚拟内存时，发现这块虚拟内存没有映射到物理内存，这时会产生缺页中断，缺页中断处理函数查看是否有空闲的物理内存，如果有就分配，没有空闲物理内存内核就会开始回收内存。  
## 回收内存的方式：  
1.  后台内存回收：物理内存紧张时会唤醒kswapd内核线程来回收内存，这个是异步的，不会阻塞进程的进行。
2.  直接内存回收：后台内存回收跟不上进程内存申请的速度，会直接开始回收，这个过程是同步的，会阻塞进程的执行。
3.  如果直接回收后空闲的物理内存仍然无法满足此次物理内存的申请，会触发OOM（out of memory）机制，根据算法选择一个占用物理内存较高的进程将其杀死，释放其内存，直到释放足够的内存位置。
## 哪些内存可以被回收？
1.  文件页：在硬盘中有载体，如内核缓存的磁盘数据和内核缓存的文件数据。分为干净页（没有被修改）和脏页（被修改），回收干净页直接释放内存，回收脏页先写入磁盘在释放内存。干净页的回收不会影响性能，脏页会发生磁盘I/O，这个操作会影响性能。  
2.  匿名页：没有实际载体，比如堆栈数据，回收方式是通过swap机制，写到磁盘后释放内存，再次访问这些内存时重新从磁盘读入内存。
文件页和匿名页的回收都是基于LRU算法
## 在4G物理内存的机器上申请8G内存会怎样？  
申请内存首先是申请虚拟内存，此时不会分配物理内存：  
1.  在32位机器上，最大的可申请的虚拟内存为3G，申请8G的虚拟内存会报错
2.  在64位机器上，最大的可申请的虚拟内存为128T，可以申请8G内存，只要不读写这个内存就不会分配物理内存。没有swap分区会因为OOM被OS杀掉，有swap分区即使物理内存只有4G也可以正常使用8G的内存。  
  



