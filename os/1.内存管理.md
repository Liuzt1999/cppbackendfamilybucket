# 虚拟内存 
os提供一种机制将不同进程的虚拟地址和不同的内存地址映射起来。  
可以使进程的运行内存超过物理内存的大小，每个进程的虚拟内存空间是私有的，可以解决多进程之间的地址冲突问题。  
## 内存分段  
分段机制下的虚拟内存地址由段选择因子（主要是段号）和段内偏移量表示。通过段号查询段表得到段的基址，再通过段内偏移量获得物理内存中的地址。  
分段管理中，不同的进程被分成不同的连续的段存储在物理内存中，这会导致：  
1. 内存碎片问题：
   主要是外部碎片，两个进程间的连续的空间不足以支持新的进程。  
2. 内存交换效率问题：
    为了解决外部碎片，使用外存当作内存的缓冲区，将物理内存中占用的内存swap到外存，再紧贴着上一块空间装载回内存。但如果交换的是一个占内存空间很大的进程，效率很低。
## 内存分页  
将内存按照固定的大小分成一个个的页（Linux下每个页的大小是4K）。通过页表来实现虚拟内存和物理内存的映射。这种方式下每个页之间都是紧凑的，不会产生外部碎片，但是页是分配的最小单元，如果一个页没有被占满，这个页也不会分配给其它的进程，因此会产生内部碎片。  
分页管理下，内存交换的单位是页，需要交换的内存空间很小，效率高。  
分页管理下的虚拟内存地址由页号和页内偏移量表示，通过页号查询页表获得页的基址，再通过页内偏移量获得物理地址。  
这种简单分页的问题：  
页表一定要能够覆盖全部的虚拟地址空间，对于32位的机器，虚拟地址空间的大小为2^32，页的大小是2^12，会产生2^20个页表项，每个页表项的大小是4字节，每个页表需要占用的空间是4MB，每个进程都有自己的虚拟地址空间，需要很大的内存来存放页表。  
为了解决这个问题，使用多级页表，如二级页表将2^20的页表分成2^10个一级页表项，每个一级页表项指向一个有2^10个页表项的二级页表。一级页表在开始就创建，而二级页表在使用的时候才会创建，通过这种方式来节省内存空间。对于64位的系统，会使用四级页表。  
多级页表的虚拟内存地址到物理内存地址的映射多了几个步骤，为了提高效率，在CPU中加入了一个专门存放最常访问的页表项的cache（TLB，页表缓存，快表）。  
## 段页式内存管理  
将程序划分成多个有逻辑意义的段（分段），再把每个段划分为多个页（分页）。这时的虚拟内存地址由段号、段内页号、页内偏移量组成。查询物理内存地址需要：
1.  访问段表得到页表起始地址
2.  访问页表得到物理页号
3.  将物理页号和页内偏移量组合得到物理地址

  



