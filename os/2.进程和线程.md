# 进程
运行中的程序  
## 进程的状态
### 三种基本状态
1.  运行态：该时刻进程占用CPU
2.  就绪态：可运行，但由于其它进程占用CPU而暂时停止运行
3.  阻塞态：等待某一事件的发生（如I/O）而暂时停止运行，即使CPU空闲也无法运行
### 另外两个状态
1.  创建状态：进程正在被创建
2.  结束状态：进程正在结束
### 挂起
大量的进程处于阻塞状态，会占用物理内存空间，通常会把阻塞态的进程换出内存，这时处于挂起状态  
挂机状态分为：  
1.  阻塞挂起：在外存等待某个事件发生
2.  就绪挂起：在外存等待进入内存后立即运行
## 进程的控制结构
操作系统中通过进程控制块（PCB）数据结构来描述进程，PCB是进程存在的唯一标识  
PCB包含的信息：  
1.  进程描述信息：包括进程标识符和用户标识符
2.  进程控制和管理信息：进程当前的状态和进程的优先级
3.  资源分配清单：分配的内存信息，打开的文件列表和使用的IO设备
4.  CPU相关信息：进程切换时CPU寄存器中的值等信息会保存在PCB，等待进程执行时恢复
OS通过链表的方式将相同状态的进程组织在一起，形成就绪队列、阻塞队列等
## 进程的控制  
1.  创建进程：
* 申请一个空白PCB，并初始化一些管控信息
* 分配资源
* 将PCB插入就绪队列
2.  终止进程：
进程的终止方式：正常结束、异常结束和外界干预（kill掉）
子进程被终止时，在父进程处继承的资源会归还父进程。父进程被终止时，该父进程的子进程变成孤儿进程，被1号进程收养，由1号进行完成回收操作
终止过程：
* 查找需要终止的进程的PCB
* 如果处于运行态则立即停止执行并将CPU资源分配给其它进程
* 如果有子进程将子进程交给1号进程接管
* 将该进程资源归还OS
* 将其PCB从所在队列删除
3.  阻塞进程：
* 找到对应的PCB
* 如果处于运行态，保护其现场并将其转为阻塞态，停止运行
* 将该PCB插入阻塞队列
4.  唤醒进程：
* 在阻塞队列找到对应PCB
* 从阻塞队列移除，置为就绪状态
* 把该PCB插入就绪队列
## 进程上下文切换
一个进程运行时切换到另一个进行运行，称为进程的上下文切换  
CPU的上下文：CPU寄存器和程序计数器  
进程是由内核调度管理的，进程的切换只能发生在内核态  
进程的上下文切换不仅包含了堆栈全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源  
通常会把交换的信息保存在PCB中，当运行另一个进程的时候，从这个进程的PCB取出上下文，然后恢复到CPU中  
进程1 -> 进程1保存上下文 -> 加载进程2上下文 -> 进程2  
发生上下文切换的场景：  
1.  时间片耗尽
2.  资源不足
3.  通过sleep等函数主动挂起
4.  优先级更高的进程运行
5.  发生硬件中断时，CPU上的进程会被挂起，转而执行内核中断处理程序
# 线程  
多进程之间通信和维护的系统开销较大，需要一个新的实体，可以并发运行且共享相同的地址空间  
## 什么是线程？  
线程是进程中的一条执行流程，同一个进程内的多个线程共享代码段、数据段、打开的文件等资源，但每个线程各自有一套独立的寄存器和栈，保证线程的控制流相对独立  
## 线程的优缺点：  
1.  优点：
* 一个进程中可以运行多个线程
* 多个线程间可以并发执行
* 同一个进程的各线程之间可以共享地址空间和文件等资源
2.  缺点：
* c++进程中的一个线程崩溃会导致该进程的所有线程崩溃，java不会
## 进程和线程的比较  
* 进程是资源（内存、打开的文件等）分配的单位，线程是CPU调度的单位
* 进程拥有完整的资源，线程只独享必不可少的资源，如寄存器和栈
* 线程同样有就绪、运行、阻塞状态
* 线程能减少并发执行的时间空间开销，具体体现在：
线程的创建不涉及资源管理信息，终止释放的资源比进程少很多，因此创建和终止比进程快  
同一个进程的线程切换比进程切换快，因为线程的虚拟内存共享，无需切换页表  
同一个进程内的线程共享内存和文件资源，通信时不需要经过内核
## 线程的实现  
1.  用户线程：在用户空间实现的线程，由用户态线程库完成线程的管理  
2.  内核线程：在内核中实现的线程，由内核管理  、
3.  轻量级线程：在内核中支持用户线程
# 调度  
进程状态发生变化时触发调度  
## 调度的原则：  
1. CPU利用率：保证CPU始终在工作
2. 系统吞吐量：单位时间内CPU完成的进程数量
3. 周转时间：进程从到来到结束的时间综总和，越小越好
4. 等待时间：处于就绪队列的时间，越短越好
5. 响应时间：用户提交请求到系统第一次产生响应的时间，在交互式系统中尤为重要
## 调度算法：  
1.  先来先服务
2.  短作业优先：长作业不利
3.  高响应比优先：（等待时间+要求服务时间）/要求服务时间，理想的算法，现实中不知道进程的运行时间
4.  时间片轮转算法：每个进程分配时间片，结束后切换，时间片过短开销大
# 进程间通信的方式：
1.  管道：
单向传输，想相互通信要创建两个管道。一个例子：ps -aux | grep mysql，这里的 | 是一个匿名管道，将ps -aux作为grep mysql的输入  
2.  消息队列：
通信不及时，不适合大文件的传输，存在用户态与内核态之间的数据拷贝开销  
3.  共享内存：
拿出一块虚拟地址空间来，映射到相同的物理空间中，不需要来回拷贝  
4.  信号量：
主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据   
5.  信号：
唯一的异步通信机制  
6.  socket：
不同主机之间的通信

