# 进程
运行中的程序  
## 进程的状态
### 三种基本状态
1.  运行态：该时刻进程占用CPU
2.  就绪态：可运行，但由于其它进程占用CPU而暂时停止运行
3.  阻塞态：等待某一事件的发生（如I/O）而暂时停止运行，即使CPU空闲也无法运行
### 另外两个状态
1.  创建状态：进程正在被创建
2.  结束状态：进程正在结束
### 挂起
大量的进程处于阻塞状态，会占用物理内存空间，通常会把阻塞态的进程换出内存，这时处于挂起状态  
挂机状态分为：  
1.  阻塞挂起：在外存等待某个事件发生
2.  就绪挂起：在外存等待进入内存后立即运行
## 进程的控制结构
操作系统中通过进程控制块（PCB）数据结构来描述进程，PCB是进程存在的唯一标识  
PCB包含的信息：  
1.  进程描述信息：包括进程标识符和用户标识符
2.  进程控制和管理信息：进程当前的状态和进程的优先级
3.  资源分配清单：分配的内存信息，打开的文件列表和使用的IO设备
4.  CPU相关信息：进程切换时CPU寄存器中的值等信息会保存在PCB，等待进程执行时恢复
OS通过链表的方式将相同状态的进程组织在一起，形成就绪队列、阻塞队列等
## 进程的控制  
1.  创建进程：
* 申请一个空白PCB，并初始化一些管控信息
* 分配资源
* 将PCB插入就绪队列
2.  终止进程：
进程的终止方式：正常结束、异常结束和外界干预（kill掉）
子进程被终止时，在父进程处继承的资源会归还父进程。父进程被终止时，该父进程的子进程变成孤儿进程，被1号进程收养，由1号进行完成回收操作
终止过程：
* 查找需要终止的进程的PCB
* 如果处于运行态则立即停止执行并将CPU资源分配给其它进程
* 如果有子进程将子进程交给1号进程接管
* 将该进程资源归还OS
* 将其PCB从所在队列删除
3.  阻塞进程：
* 找到对应的PCB
* 如果处于运行态，保护其现场并将其转为阻塞态，停止运行
* 将该PCB插入阻塞队列
4.  唤醒进程：
* 在阻塞队列找到对应PCB
* 从阻塞队列移除，置为就绪状态
* 把该PCB插入就绪队列
## 进程上下文切换
一个进程运行时切换到另一个进行运行，称为进程的上下文切换  
CPU的上下文：CPU寄存器和程序计数器  
进程是由内核调度管理的，进程的切换只能发生在内核态  
进程的上下文切换不仅包含了堆栈全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源  
通常会把交换的信息保存在PCB中，当运行另一个进程的时候，从这个进程的PCB取出上下文，然后恢复到CPU中  
进程1 -> 进程1保存上下文 -> 加载进程2上下文 -> 进程2  
发生上下文切换的场景：  
1.  时间片耗尽
2.  资源不足
3.  通过sleep等函数主动挂起
4.  优先级更高的进程运行
5.  发生硬件中断时，CPU上的进程会被挂起，转而执行内核中断处理程序
# 线程  
多进程之间通信和维护的系统开销较大，需要一个新的实体，可以并发运行且共享相同的地址空间  
## 什么是线程？  
线程是进程中的一条执行流程，同一个进程内的多个线程共享代码段、数据段、打开的文件等资源，但每个线程各自有一套独立的寄存器和栈，保证线程的控制流相对独立  
## 线程的优缺点：  
1.  优点：
* 一个进程中可以运行多个线程
* 多个线程间可以并发执行
* 同一个进程的各线程之间可以共享地址空间和文件等资源
2.  缺点：
* c++进程中的一个线程崩溃会导致该进程的所有线程崩溃，java不会
## 进程和线程的比较  
* 进程是资源（内存、打开的文件等）分配的单位，线程是CPU调度的单位
* 进程拥有完整的资源，线程只独享必不可少的资源，如寄存器和栈
* 线程同样有就绪、运行、阻塞状态
* 线程能减少并发执行的时间空间开销，具体体现在：
线程的创建不涉及资源管理信息，终止释放的资源比进程少很多，因此创建和终止比进程快  
同一个进程的线程切换比进程切换快，因为线程的虚拟内存共享，无需切换页表  
同一个进程内的线程共享内存和文件资源，通信时不需要经过内核
## 线程的实现  
1.  用户线程：在用户空间实现的线程，由用户态线程库完成线程的管理  
2.  内核线程：在内核中实现的线程，由内核管理  、
3.  轻量级线程：在内核中支持用户线程
# 调度  
进程状态发生变化时触发调度  
## 调度的原则：  
1. CPU利用率：保证CPU始终在工作
2. 系统吞吐量：单位时间内CPU完成的进程数量
3. 周转时间：进程从到来到结束的时间综总和，越小越好
4. 等待时间：处于就绪队列的时间，越短越好
5. 响应时间：用户提交请求到系统第一次产生响应的时间，在交互式系统中尤为重要
## 调度算法：  
1.  先来先服务
2.  短作业优先：长作业不利
3.  高响应比优先：（等待时间+要求服务时间）/要求服务时间，理想的算法，现实中不知道进程的运行时间
4.  时间片轮转算法：每个进程分配时间片，结束后切换，时间片过短开销大
# 进程间通信的方式：
1.  管道：
单向传输，想相互通信要创建两个管道。一个例子：ps -aux | grep mysql，这里的 | 是一个匿名管道，将ps -aux作为grep mysql的输入  
2.  消息队列：
通信不及时，不适合大文件的传输，存在用户态与内核态之间的数据拷贝开销  
3.  共享内存：
拿出一块虚拟地址空间来，映射到相同的物理空间中，不需要来回拷贝  
4.  信号量：
主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据   
5.  信号：
唯一的异步通信机制  
6.  socket：
不同主机之间的通信
# 多线程冲突
## 互斥与同步
1.  互斥：多线程操作共享变量的代码会导致竞争状态，这段代码称为临界区，一个线程在临界区执行时，其它线程应该被阻止进入临界区
2.  同步：并发进程/线程间在一些关键点上可能需要互相等待或互通消息，这个行为称为同步
## 互斥与同步的实现与使用
主要有两种方法：  
* 锁：加锁、解锁操作；
* 信号量：P、V操作；
这两个都可以实现互斥，信号量比锁的功能更强一些，还可以实现同步
### 锁
使用加锁和解锁操作解决并发线程的互斥问题：  
任何想进入临界区的线程必须先执行加锁操作。如果加锁操作通过则线程可以进入临界区，完成对临界资源的访问后再执行解锁操作。  
根据锁的实现分为：忙等待锁和无忙等待锁：  
* 忙等待锁（自旋锁）：在获取不到锁时，线程会一直等待（自旋），期间会占用CPU。
* 无等待锁：在获取不到锁时，把当前线程放入锁的等待队列，然后执行调度把CPU给其它线程执行。
### 信号量
通常信号量表示资源的数量，对应一个整型变量sem。有两个原子操作的系统调用函数来控制：  
* P操作：将sem减一，相减后如果sem < 0，则线程/进程进入阻塞等待，否则继续。
* V操作：将sem加一，相加后如果sem <= 0，则唤醒一个等待中的进程/线程。
#### 使用信号量实现临界区的互斥访问  
将sem初值置为1，每个进程/线程进入临界区前先执行P操作，sem变为0，下一个进程想要进入时执行P操作后sem变为负值，线程阻塞。  
# 死锁问题
## 死锁的概念
两个线程都在等待对方释放锁，在没有外力的作用下这些线程会一直相互等待，没有办法继续运行。  
死锁只有同时满足以下四个条件才会发生：  
* 互斥条件：多个线程不能同时使用同一个资源
* 占有并等待条件：线程在等待资源的同时不会释放自己已经持有的资源
* 不可剥夺条件：线程持有的资源在使用完之前不能被其它线程获取
* 循环等待条件：构成环形链
## 利用工具排查死锁问题
java可以使用jstack，c++在linux下可以使用pstack+gdb来定位  
## 避免死锁问题的发生
破坏产生死锁的四个必要条件之一就可以解除死锁  
最常用的是使用资源有序分配法破坏循环等待条件  
# 乐观锁和悲观锁
* 乐观锁认为多线程同时修改共享资源的概率很低，先修改完资源，再验证这段时间内有没有发生冲突，如果没有其它线程修改资源就完成操作，如果有其他线程已经修改过这个资源就放弃本次操作。乐观锁全程没有加锁，又叫无锁编程。
* 悲观锁认为多线程同时修改共享资源的概率比较高，访问共享资源前先加锁。
# 为什么c++中线程崩溃会引起进程崩溃而java中不会  
在进程中各线程的地址空间是共享的，某个线程对地址的非法访问会导致内存的不确定性，进而影响其它线程，因此OS让整个进程都崩溃。进程崩溃是通过信号完成的，JVM定义了自己的信号处理函数，拦截了OS的信号，因此进程不会崩溃。  




