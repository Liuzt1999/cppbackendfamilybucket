#  什么是线程池  
    服务器预先创建的一组子线程，所有的子线程都运行着相同的代码，当新任务到来时，  
    主线程将通过某种方式选择线程池中的某个子线程来为之服务。
#  为什么使用线程池  
    一方面可以限制应用程序中同时运行的线程数，因为创建一个新线程会带来性能开销  
    每个线程也会为其堆栈分配一些内存。  
    另一方面，提前创建线程池，将任务传递到线程池处理，而不是为每个任务动态创建  
    一个新线程，可以提高并发执行的效率。  
#  处理过程中，如何选择线程池中的线程
    随机算法  
    轮流选取算法  
    通过一个共享工作队列（list单链表）来同步，子线程都睡眠在该工作队列上，  
    当工作队列中任务到来时，子线程并发参与竞争  
#  线程的同步机制
    互斥锁，信号量，条件变量等
    互斥锁用于互斥控制，信号量可以用于进程或线程间的通信，条件变量用于线程间的通信
#  介绍一下几种典型的锁  
    读写锁：多个读者可以同时读，读者和写者、写者和写者互斥，写者优先级高（有限唤醒写者）  
    互斥锁：一次只能一个线程拥有互斥锁，其他线程等待。
            线程在抢占互斥锁失败的情况下主动进入睡眠状态直到锁的状态改变时再唤醒，  
            为了实现锁的状态改变时唤醒阻塞的进程或线程，需要把锁交给操作系统管理，  
            这涉及到上下文的切换，影响效率。但实际上互斥锁的效率还可以接受，加锁的  
            时间大概100ns左右。
            而实际上互斥锁的实现是先自旋一段时间，当自旋时间超过阈值再将线程投入睡  
            眠，因此在并发中的效率可能不亚于自旋锁。  
    条件变量：互斥锁只有两种状态。而条件变量通过允许线程阻塞等待另一个线程发送信号  
              的方法弥补了互斥锁的不足，常和互斥锁一起使用，以免出现竞态条件。互斥  
              锁是线程间的互斥机制，条件变量是同步机制。  
    自旋锁：如果线程无法取得锁，不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到  
            获取为止。如果别的线程长期占用锁，自旋锁就是浪费CPU做无用功，但自旋锁一  
            般用于加锁时间很短的场景，此时效率比较高。  
#  线程数量的选择
    针对不同的任务性质而言：CPU密集型任务应配置尽可能小的线程数。I/O密集型任务应配置  
    尽可能多的线程，因为I/O操作不占用CPU。总之根据CPU的使用情况决定，如果CPU利用率低  
    就分配更多的线程。
#  线程池中的工作线程是一直等待吗？
    线程池中的工作线程是处于阻塞等待的模式下的。为了处理高并发问题，让线程池中的工作  
    线程都设置为阻塞等待在请求队列上，直到请求队列非空。
#  工作线程处理完一个任务后的状态
    如果请求队列为空，则这个线程阻塞等待  
    如果请求队列非空，则这个线程参与和其它线程的竞争  
#  如果同时有10000个客户端进行访问，线程数不多，怎么能及时响应每一个请求呢？
    通过对子线程循环调用来解决高并发的问题。 并不是一个请求对应一个线程，当客户连接有请求  
    发生，epoll会进行通知，然后将对应的任务加入请求队列，等待工作线程竞争执行。 
    使用while循环让线程池中的线程永远不会停止，循环访问请求队列，如果请求队列为空就阻塞  
    等待，有任务线程就抢占式进行处理，直到请求队列为空。
    如果当前的线程数量不足以满足需求，可以考虑增大线程池容量，或者考虑集群分布式做法。  
    如果CPU性能是瓶颈可以考虑增加计算资源。  
#  一个客户端占用线程时间很久会不会影响下面的客户，有什么解决策略？  
    线程池中的线程是固定的，一个客户端长时间占用线程影响并发，可以给每个线程处理任务的时间  
    设置一个阈值，超过这个阈值就将这个请求放到请求队列末尾。   
